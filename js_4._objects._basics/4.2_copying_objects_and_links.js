// 1. Копирование объектов и ссылки

// Объекты хранятся и копируются «по ссылке».
// Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».

// Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.

// Сам объект хранится где-то в памяти. А в переменной user лежит «ссылка» на эту область памяти.

// Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.

// Мы можем использовать любую из переменных для доступа к ящику и изменения его содержимого:

// let user = { name: 'Иван' };
// let admin = user;
// 
// admin.name = 'Петя'; // изменено по ссылке из переменной "admin"
// alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"

// Приведённый выше пример демонстрирует, что объект только один. 
// Как если бы у нас был один ящик с двумя ключами и мы использовали один из них (admin), 
// чтобы войти в него и что-то изменить, а затем, открыв ящик другим ключом (user), 
// мы бы увидели эти изменения.

// 2. Сравнение по ссылке

// ! Операторы равенства == и строгого равенства === для объектов работают одинаково.

// Два объекта равны только в том случае, если это один и тот же объект.

// В примере ниже две переменные ссылаются на один и тот же объект, поэтому они равны друг другу:
// let a = {};
// let b = a; // копирование по ссылке
// 
// alert( a == b ); // true, т.к. обе переменные ссылаются на один и тот же объект
// alert( a === b ); // true

// В другом примере два разных объекта не равны, хотя оба пусты:
// let a = {};
// let b = {}; // два независимых объекта
// 
// alert( a == b ); // false

// Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы.
// сравнения такого рода необходимы очень редко и обычно являются результатом ошибки программиста.

// 2. Клонирование и объединение объектов, Object.assign

// 2.1 Нужно создавать новый объект и повторять структуру дублируемого объекта, перебирая его свойства и копируя их.

// let user = {
//   name: "Иван",
//   age: 30
// };
// 
// let clone = {}; // новый пустой объект
// 
// // скопируем все свойства user в него
// for (let key in user) {
//   clone[key] = user[key];
// }
// 
// // теперь в переменной clone находится абсолютно независимый клон объекта
// clone.name = "Пётр"; // изменим в нём данные
// 
// alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Иван.

// 2.2 Метод Object.assign. Можем использовать для клонирования объектов.

// Object.assign(dest, [src1, src2, src3...])

// - Первый аргумент dest — целевой объект.
// - Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно) 
//   являются исходными объектами
// - Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. 
//   То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
// - Возвращает объект dest.

// Объединим несколько объектов в один:
// let user = { name: "Иван" };
// 
// let permissions1 = { canView: true };
// let permissions2 = { canEdit: true };
// 
// // копируем все свойства из permissions1 и permissions2 в user
// Object.assign(user, permissions1, permissions2);
// 
// // теперь user = { name: "Иван", canView: true, canEdit: true }

// Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:

// let user = { name: "Иван" };
// 
// Object.assign(user, { name: "Пётр" });
// 
// alert(user.name); // теперь user = { name: "Пётр" }

// Мы также можем использовать Object.assign для замены for..in на простое клонирование:

// let user = {
//   name: "Иван",
//   age: 30
// };
// 
// let clone = Object.assign({}, user);

// Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.

// 2.3 Вложенное клонирование

// До сих пор мы предполагали, что все свойства объекта user хранят примитивные значения. 
// Но свойства могут быть ссылками на другие объекты. 
// Что с ними делать?

// let user = {
//   name: "Иван",
//   sizes: {
//     height: 182,
//     width: 50
//   }
// };
// 
// alert( user.sizes.height ); // 182

// Теперь при клонировании недостаточно просто скопировать clone.sizes = user.sizes, 
// поскольку user.sizes – это объект, он будет скопирован по ссылке. 
// А значит объекты clone и user в своих свойствах sizes будут ссылаться на один и тот же объект:

// let user = {
//   name: "Иван",
//   sizes: {
//     height: 182,
//     width: 50
//   }
// };
// 
// let clone = Object.assign({}, user);
// 
// alert( user.sizes === clone.sizes ); // true, один и тот же объект
// 
// // user и clone обращаются к одному sizes
// user.sizes.width++;       // меняем свойство в одном объекте
// alert(clone.sizes.width); // 51, видим результат в другом объекте

// Чтобы исправить это, мы должны в цикле клонирования делать проверку, 
// не является ли значение user[key] объектом, и если это так – скопировать и его структуру тоже. 

// Это называется «глубокое клонирование».

// Мы можем реализовать глубокое клонирование, используя:
// - рекурсию
// - метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.

// 2.4 Итого

// Объекты присваиваются и копируются по ссылке. 
// Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение. 
// Поэтому копирование такой переменной или передача её в качестве аргумента функции приводит к 
// копированию этой ссылки, а не самого объекта.

// Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) 
// выполняются с одним и тем же объектом.

// Для «простого клонирования» объекта можно использовать Object.assign. 
// Необходимо помнить, что Object.assign не делает глубокое клонирование объекта. 
// Если внутри копируемого объекта есть свойство, значение которого не является примитивом, 
// будет передано по ссылке. 

// Для создания «настоящей копии» (полного клона объекта) можно воспользоваться методом 
// из сторонней JavaScript-библиотеки _.cloneDeep(obj).