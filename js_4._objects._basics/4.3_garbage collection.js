// 1. Достижимость

// Основной концепцией управления памятью в JavaScript является принцип ДОСТИЖИМОСТИ.

// «ДОСТИЖИМЫЕ» значения – это те, которые доступны или используются. 
// Они гарантированно находятся в памяти.

// 1.1 Существует базовое множество достижимых значений, которые не могут быть удалены.

// Например:
// Локальные переменные и параметры текущей функции.
// Переменные и параметры других функций в текущей цепочке вложенных вызовов.
// Глобальные переменные.
// (некоторые другие внутренние значения)
// Эти значения мы будем называть корнями.

// 1.2 Любое другое значение считается достижимым, если оно доступно из корня по ссылке 
// или по цепочке ссылок.

// Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка 
// на другой объект, то этот объект считается достижимым. 
// И те, на которые он ссылается, тоже достижимы.

// В интерпретаторе JavaScript есть фоновый процесс, который называется сборщик мусора. 
// Он следит за всеми объектами и удаляет те, которые стали недостижимы.

// 2. Простой пример

// в user находится ссылка на объект
// let user = {
//   name: "John"
// };

// Глобальная переменная user ссылается на объект {name: "John"} (мы будем называть его просто «John»). 
// В свойстве "name" объекта John хранится примитив.

// Если перезаписать значение user, то ссылка потеряется:
// user = null;

// Теперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. 
// Сборщик мусора удалит эти данные и освободит память.

// 3. Две ссылки

// Представим, что мы скопировали ссылку из user в admin:
// в user находится ссылка на объект
// let user = {
//   name: "John"
// };
// 
// let admin = user;

// Теперь, если мы сделаем то же самое:
// user = null;

// объект John всё ещё достижим через глобальную переменную admin, поэтому он находится в памяти. 
// Если бы мы также перезаписали admin, то John был бы удалён.

// 4. Взаимосвязанные объекты

// Более сложный пример. Семья:
// function marry(man, woman) {
//   woman.husband = man;
//   man.wife = woman;
// 
//   return {
//     father: man,
//     mother: woman
//   }
// }
// 
// let family = marry({
//   name: "John"
// }, {
//   name: "Ann"
// });

// Функция marry «женит» два объекта, давая им ссылки друг на друга, и возвращает новый объект, 
// содержащий ссылки на два предыдущих.

// Теперь удалим две ссылки:
// delete family.father;
// delete family.mother.husband;

// Недостаточно удалить только одну из этих ссылок, потому что все объекты останутся достижимыми.
// Но если мы удалим обе, то увидим, что у объекта John больше нет входящих ссылок

// Исходящие ссылки не имеют значения. Только входящие ссылки могут сделать объект достижимым. 
// Объект John теперь недостижим и будет удалён из памяти со всеми своими данными, 
// которые также стали недоступны.

// 5. Недостижимый «остров»

// Вполне возможна ситуация, при которой целый «остров» связанных объектов может стать недостижимым 
// и удалиться из памяти.

// Возьмём объект family из примера выше. А затем:
// family = null;

// Этот пример демонстрирует, насколько важна концепция достижимости.

// Объекты John и Ann всё ещё связаны, оба имеют входящие ссылки, но этого недостаточно.
// У объекта family больше нет ссылки от корня, поэтому весь «остров» становится недостижимым и будет удалён.

// 6. Внутренние алгоритмы

// Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).

// Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:
// 1. Сборщик мусора «помечает» (запоминает) все корневые объекты.
// 2. Затем он идёт по их ссылкам и помечает все найденные объекты.
// 3. Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. 
//    Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
// 4. …И так далее, пока не будут посещены все ссылки (достижимые от корней).
// 5. Все непомеченные объекты удаляются.

// Вот некоторые из оптимизаций:
// - Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». 
//   Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. 
//   Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
// 
// - Инкрементальная сборка (Incremental collection) – если объектов много, то обход всех ссылок 
//   и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. 
//   Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. 
//   Это требует дополнительного учёта для отслеживания изменений между этапами, 
//   но зато теперь у нас есть много крошечных задержек вместо одной большой.
// 
// - Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, 
//   сборщик мусора старается работать только во время простоя процессора.

// 7. Итого

// Главное из того, что мы узнали:
// - Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
// Объекты сохраняются в памяти, пока они достижимы.
// Наличие ссылки не гарантирует, что объект достижим (от корня): несколько взаимосвязанных объектов могут стать недостижимыми как единое целое.
// Современные интерпретаторы реализуют передовые алгоритмы сборки мусора.
