// 1. Конструкторы, создание объектов через "new"

// Обычный синтаксис {...} позволяет создать только один объект. 
// Но зачастую нам нужно создать множество однотипных объектов, таких как пользователи, 
// элементы меню и т.д.

// Это можно сделать при помощи функции-конструктора и оператора "new".

// 2. Функция-конструктор

// Функции-конструкторы являются обычными функциями. Но есть два соглашения:
// - Имя функции-конструктора должно начинаться с большой буквы.
// - Функция-конструктор должна вызываться при помощи оператора "new".

// function User(name) {
//     this.name = name;
//     this.isAdmin = false;
//   }
  
//   let user = new User("Вася");
  
//   alert(user.name); // Вася
//   alert(user.isAdmin); // false

// Когда функция вызывается как new User(...), происходит следующее:
// - Создаётся новый пустой объект, и он присваивается this.
// - Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства.
// - Возвращается значение this.

// Другими словами, вызов new User(...) делает примерно вот что:

// function User(name) {
//     // this = {};  (неявно)
//   
//     // добавляет свойства к this
//     this.name = name;
//     this.isAdmin = false;
//   
//     // return this;  (неявно)
//   }

// результат вызова let user = new User("Вася") – это тот же объект, что и:

// let user = {
//     name: "Вася",
//     isAdmin: false
//   };

// 3. new function() { … }

// Если в нашем коде большое количество строк, создающих один сложный объект, 
// мы можем обернуть их в функцию-конструктор следующим образом:

// let user = new function() {
//     this.name = "Вася";
//     this.isAdmin = false;
  
//     // ...другой код для создания пользователя
//     // возможна любая сложная логика и выражения
//     // локальные переменные и т. д.
//   };

// Такой конструктор не может быть вызван дважды, так как он нигде не сохраняется, 
// просто создаётся и тут же вызывается. 
// Такой метод создания позволяет инкапсулировать код, который создаёт отдельный объект, 
// но без возможности его повторного использования.

// 4. Проверка на вызов в режиме конструктора: new.target

// Продвинутая возможность
// Используя специальное свойство new.target внутри функции, мы можем проверить, 
// вызвана ли функция при помощи оператора new или без него.

// В случае, если функция вызвана при помощи new, то в new.target будет сама функция, 
// в противном случае undefined.

// function User() {
//     alert(new.target);
//   }
// 
//   // без "new":
//   User(); // undefined
// 
//   // с "new":
//   new User(); // function User { ... }

// Это можно использовать, чтобы отличить обычный вызов от вызова «в режиме конструктора». 

// В частности, вот так можно сделать, чтобы функцию можно было вызывать как с, так и без new:

// function User(name) {
//     if (!new.target) { // в случае, если вы вызвали без оператора new
//       return new User(name); // ...добавим оператор new за вас
//     }
//   
//     this.name = name;
//   }
//   
//   let vasya = User("Вася"); // переадресовывает вызовы на new User
//   alert(vasya.name); // Вася

// Такой подход иногда используется в библиотеках для создания более гибкого синтаксиса, 
// который позволяет разработчикам вызывать функции при помощи оператора new или без него.

// Впрочем, это не очень хорошая практика, так как отсутствие new может ввести разработчика в заблуждение. 
// С оператором new мы точно знаем, что в итоге будет создан новый объект.

// 5. Возврат значения из конструктора return

// Обычно конструкторы ничего не возвращают явно. 
// Их задача – записать все необходимое в this, который в итоге станет результатом.

// Но если return всё же есть, то применяется простое правило:
// - При вызове return с объектом, будет возвращён объект, а не this.
// - При вызове return с примитивным значением, примитивное значение будет отброшено.

// Другими словами, return с объектом возвращает объект, 
// в любом другом случае конструктор вернёт this.

// В примере ниже return возвращает объект вместо this:
// function BigUser() {
// 
//     this.name = "Вася";
//   
//     return { name: "Godzilla" };  // <-- возвращает этот объект
//   }
//   
//   alert( new BigUser().name );  // Godzilla, получили этот объект

// А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно)

// function SmallUser() {
// 
//     this.name = "Вася";
//   
//     return; // <-- возвращает this
//   }
//   
//   alert( new SmallUser().name );  // Вася

// 6. Создание методов в конструкторе

// В this мы можем добавлять не только свойства, но и методы.

// Например, в примере ниже, new User(name) создаёт объект с данным именем name и методом sayHi:

// function User(name) {
//   this.name = name;
// 
//   this.sayHi = function() {
//     alert( "Меня зовут: " + this.name );
//   };
// }
// 
// let vasya = new User("Вася");
// 
// vasya.sayHi(); // Меня зовут: Вася
// 
// /*
// vasya = {
//    name: "Вася",
//    sayHi: function() { ... }
// }
// */

// 7. Итого
// - Функции-конструкторы или просто конструкторы являются обычными функциями, 
//   именовать которые следует с заглавной буквы.
// - Конструкторы следует вызывать при помощи оператора new. 
//   Такой вызов создаёт пустой this в начале выполнения и возвращает заполненный в конце.
// - Мы можем использовать конструкторы для создания множества похожих объектов.
