// 1. Тип данных Symbol

// По спецификации, в качестве ключей для свойств объекта могут использоваться 
// только строки или символы

// 2. Символы

// «Символ» представляет собой уникальный идентификатор.

// Создание
// с помощью функции Symbol():

// Создаём новый символ - id
// let id = Symbol();

// можно дать описание (также называемое ИМЯ)

// Создаём символ id с описанием (именем) "id"
// let id = Symbol("id");

// !!! Символы ГАРАНТИРОАННО уникальны

// если мы создадим множество символов с одинаковым описанием, 
// это всё равно будут разные символы

// let id1 = Symbol("id");
// let id2 = Symbol("id");
// alert(id1 == id2); // false

// 3. !!! Символы НЕ ПРЕОБРАЗУЮТСЯ автоматически в строки

// Большинство типов данных в JavaScript могут быть неявно преобразованы в строку.
// Например, функция alert принимает практически любое значение, автоматически 
// преобразовывает его в строку, а затем выводит это значение, не сообщая об ошибке. 

// Символы же особенные и не преобразуются автоматически.

// let id = Symbol("id");
// alert(id); // TypeError: Cannot convert a Symbol value to a string

// Это – языковая «защита» от путаницы, ведь строки и символы – 
// принципиально разные типы данных и не должны неконтролируемо преобразовываться 
// друг в друга.

// Если же мы действительно хотим вывести символ с помощью 
// alert, 
// то необходимо явно преобразовать его с помощью метода
// .toString()
// , вот так:
// let id = Symbol("id");
// alert(id.toString()); // Symbol(id), теперь работает


// Или мы можем обратиться к свойству
// symbol.description 
// ,чтобы вывести только описание:
// let id = Symbol("id");
// alert(id.description); // id

// 4. «Скрытые» свойства

// Символы позволяют создавать «скрытые» свойства объектов, 
// к которым нельзя нечаянно обратиться и перезаписать их 
// из других частей программы.

// Например, мы работаем с объектами user, которые принадлежат стороннему коду. 
// Мы хотим добавить к ним идентификаторы

// Используем для этого символьный ключ:
// let user = {
//     name: "Вася"
//   };
//   
//   let id = Symbol("id");
//   
//   user[id] = 1;
//   
//   alert( user[id] ); // мы можем получить доступ к данным по ключу-символу

// лучше использовать Symbol("id"), а не строку "id"

// Так как объект user принадлежит стороннему коду, и этот код также работает 
// с ним, то нам не следует добавлять к нему какие-либо поля. 
// Это небезопасно.

// Сторонний код может создать для этого свой символ Symbol("id"):
// let id = Symbol("id");
// user[id] = "Их идентификатор";

// Конфликта между их и нашим идентификатором не будет, 
// так как СИМВОЛЫ ВСЕГДА УНИКАЛЬНЫ, даже если их имена совпадают.

// если бы мы использовали строку "id" вместо символа, то тогда был бы конфликт:
// let user = { name: "Вася" };
// 
// Объявляем в нашем скрипте свойство "id"
// user.id = "Наш идентификатор";
// 
// ...другой скрипт тоже хочет свой идентификатор...
// 
// user.id = "Их идентификатор"
// Ой! Свойство перезаписано сторонней библиотекой!

// 5. Символы в литеральном объекте

// Если мы хотим использовать символ при литеральном объявлении объекта {...}, 
// его необходимо заключить в квадратные скобки.

// let id = Symbol("id");
// 
// let user = {
//   name: "Вася",
//   [id]: 123 // просто "id: 123" не сработает
// };

// Это вызвано тем, что нам нужно использовать значение переменной id 
// в качестве ключа, а не строку «id».

// 6. Символы игнорируются циклом for…in

// Свойства, чьи ключи – символы, не перебираются циклом for..in.
// let id = Symbol("id");
// let user = {
//   name: "Вася",
//   age: 30,
//   [id]: 123
// };
// 
// for (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)
// 
// // хотя прямой доступ по символу работает
// alert( "Напрямую: " + user[id] );

// Object.assign
// , в отличие от цикла for..in, копирует и строковые, и символьные свойства:
// let id = Symbol("id");
// let user = {
//   [id]: 123
// };
// 
// let clone = Object.assign({}, user);
// 
// alert( clone[id] ); // 123

// когда мы клонируем или объединяем объекты, мы хотим скопировать все свойства
// (включая такие свойства с ключами-символами, как, например, id в примере выше).

// 7. Глобальные символы

// иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью. 
// Например, разные части нашего приложения хотят получить доступ к символу "id", 
// подразумевая именно одно и то же свойство.

// Для этого существует ГЛОБАЛЬНЫЙ РЕЕСТР символов

// Для чтения (или, при отсутствии, создания) символа из реестра используется вызов 
// Symbol.for(key)

// Он проверяет глобальный реестр и, при наличии в нём символа с именем key, 
// возвращает его, 
// иначе же создаётся новый символ Symbol(key) 
// и записывается в реестр под ключом key.

// читаем символ из глобального реестра и записываем его в переменную
// let id = Symbol.for("id"); // если символа не существует, он будет создан
// 
// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
// let idAgain = Symbol.for("id");
// 
// проверяем -- это один и тот же символ
// alert( id === idAgain ); // true

// Символы, содержащиеся в реестре, называются ГЛОБАЛЬНЫМИ СИМВОЛАМИ. 

// !!! Если вам нужен символ, доступный везде в коде – используйте глобальные символы.

// 8. Symbol.keyFor

// Для глобальных символов, кроме 
// Symbol.for(key)
// , который ищет символ по имени, существует обратный метод: 
// Symbol.keyFor(sym)
// , который, наоборот, принимает глобальный символ и возвращает его имя.

// получаем символ по имени
// let sym = Symbol.for("name");
// let sym2 = Symbol.for("id");
// 
// получаем имя по символу
// alert( Symbol.keyFor(sym) ); // name
// alert( Symbol.keyFor(sym2) ); // id

// Внутри метода 
// Symbol.keyFor 
// используется глобальный реестр символов для нахождения имени символа. 
// Так что этот метод не будет работать для НЕГЛОБАЛЬНЫХ символов. 
// Если символ неглобальный, метод не сможет его найти и вернёт undefined.

// Впрочем, для любых символов доступно свойство description.

// let globalSymbol = Symbol.for("name");
// let localSymbol = Symbol("name");
// 
// alert( Symbol.keyFor(globalSymbol) ); // name, глобальный символ
// alert( Symbol.keyFor(localSymbol) ); // undefined для неглобального символа
// 
// alert( localSymbol.description ); // name

//  9. Системные символы

// Существует множество «системных» символов, использующихся внутри 
// самого JavaScript, и мы можем использовать их, 
// чтобы настраивать различные аспекты поведения объектов.

// Эти символы перечислены в спецификации в таблице Well-known symbols:
// 
// Symbol.hasInstance
// Symbol.isConcatSpreadable
// Symbol.iterator
// Symbol.toPrimitive
// …и так далее.

// Symbol.toPrimitive
// позволяет описать правила для объекта, согласно которым 
// он будет преобразовываться к примитиву.

// 10. Итого

// Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

// Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.

// Даже если символы имеют одно и то же имя, это – разные символы. 
// Если мы хотим, чтобы одноимённые символы были равны, то следует использовать 
// глобальный реестр: вызов 
// Symbol.for(key) 
// возвращает (или создаёт) глобальный символ с key в качестве имени. 
// Многократные вызовы команды 
// Symbol.for 
// с одним и тем же аргументом возвращают один и тот же символ.

// Символы имеют два основных варианта использования:

// 1. «Скрытые» свойства объектов. 
//    Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, 
//    мы можем создать символ и использовать его в качестве ключа. 
//    Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими. 
//    Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. 
//    Таким образом, свойство будет защищено от случайной перезаписи или использования.

// 2. Существует множество системных символов, используемых внутри JavaScript, доступных как 
//   Symbol.*
//   Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. 
//   Например, в дальнейших главах мы будем использовать 
//   Symbol.iterator 
//   для итераторов, 
//   Symbol.toPrimitive 
//   для настройки преобразования объектов в примитивы и так далее.

// Технически символы скрыты не на 100%. 

// Существует встроенный метод 
// Object.getOwnPropertySymbols(obj)
//  – с его помощью можно получить все свойства объекта с ключами-символами. 

// Также существует метод 
// Reflect.ownKeys(obj)
// , который возвращает все ключи объекта, включая символьные. 

// Так что они не совсем спрятаны. 

// Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.


