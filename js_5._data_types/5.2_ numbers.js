// 1.Числа

// существует два типа чисел:
// 1.1 Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, 
//     который также называют «числа с плавающей точкой двойной точности» 
//     (double precision floating point numbers). 
//     Это числа, которые мы будем использовать чаще всего. 
// 1.2 BigInt числа дают возможность работать с целыми числами произвольной длины. 
//     Они используются в случаях, когда необходимо работать со значениями 
//     более чем 2**53 или менее чем -2**53. 
//     Так как BigInt числа нужны достаточно редко, мы рассмотрим их в отдельной главе BigInt.

// 2. Способы записи числа

// Самый очевидный путь:
// let billion = 1000000000;

// В JavaScript используют букву "e", чтобы укоротить запись числа. 
// Она добавляется к числу и заменяет указанное количество нулей:
// let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
// alert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)

// "e" производит операцию умножения числа на 1 с указанным количеством нулей.
// 1e3 = 1 * 1000
// 1.23e6 = 1.23 * 1000000

// let ms = 0.000001;
// let ms = 1e-6; // шесть нулей, слева от 1

// отрицательное число после "e" подразумевает деление на 1 с указанным количеством нулей:

// 1 делится на 1 с 3 нулями
// 1e-3 = 1 / 1000 (=0.001)

// 1.23 делится на 1 с 6 нулями
// 1.23e-6 = 1.23 / 1000000 (=0.00000123)

// 2. Шестнадцатеричные, двоичные и восьмеричные числа

// Шестнадцатеричные числа широко используются в JavaScript для представления 
// цветов, кодировки символов и многого другого.

// Шестнадцатиричный короткий стиль записи: 0x, после которого указывается число.

// alert( 0xff ); // 255
// alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)

// двоичный короткий стиль записи: 0b

// восьмиричный короткий стиль записи: 0o

// let a = 0b11111111; // бинарная форма записи числа 255
// let b = 0o377; // восьмеричная форма записи числа 255
// alert( a == b ); // true, с двух сторон число 255

// Есть только 3 системы счисления с такой поддержкой. 
// Для других систем счисления мы рекомендуем использовать функцию parseInt 

// 3. toString(base)

// Метод 
// num.toString(base) 
// возвращает строковое представление числа num в системе счисления base.

// let num = 255;
// 
// alert( num.toString(16) );  // ff
// alert( num.toString(2) );   // 11111111

// base может варьироваться от 2 до 36 (по умолчанию 10).

// Часто используемые:
// - base=16 — для шестнадцатеричного представления цвета, 
//   кодировки символов и т.д., цифры могут быть 0..9 или A..F.
// - base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.
// - base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. 
//   То есть, используется весь латинский алфавит для представления числа.

// можно использовать 36-разрядную систему счисления для получения 
// короткого представления большого числового идентификатора.
// К примеру, для создания короткой ссылки. 
// Для этого просто преобразуем его в 36-разрядную систему счисления:

// alert( 123456..toString(36) ); // 2n9c

// 4. Две точки для вызова метода

// !!! Внимание! Две точки в 123456..toString(36) это НЕ ОПЕЧАТКА.

// Если нам надо вызвать метод непосредственно на числе, 
// как toString в примере выше, то нам надо поставить две точки .. после числа.

// Если мы поставим одну точку: 123456.toString(36), 
// тогда это будет ошибкой, 
// поскольку синтаксис JavaScript предполагает, 
// что после первой точки начинается десятичная часть. 
// А если поставить две точки, то JavaScript понимает, 
// что десятичная часть отсутствует, и начинается метод.

// Также можно записать как (123456).toString(36).

// 5. Округление

// есть несколько встроенных функций для работы с округлением:

// Math.floor
// Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.

// Math.ceil
// Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.

// Math.round
// Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.

// Math.trunc
// Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
// (не поддерживается в Internet Explorer)

// если нам надо округлить число до n-ого количества цифр в дробной части

// Есть два пути решения:

// 1. Умножить и разделить.
// Например, чтобы округлить число до второго знака после запятой, мы можем 
// умножить число на 100, вызвать функцию округления и разделить обратно.

// let num = 1.23456;
// alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23

// 2.  toFixed(n) 
// метод округляет число до n знаков после запятой и 
// возвращает СТРОКОВОЕ представление результата.

// let num = 12.34;
// alert( num.toFixed(1) ); // "12.3"

// Округляет значение до ближайшего числа, как в большую, 
// так и в меньшую сторону, аналогично методу Math.round:

// let num = 12.36;
// alert( num.toFixed(1) ); // "12.4"

// Обратите внимание, что результатом toFixed является строка. 
// Если десятичная часть короче, чем необходима, 
// будут добавлены нули в конец строки:

// let num = 12.34;
// alert( num.toFixed(5) ); // "12.34000", добавлены нули, 
//                              чтобы получить 5 знаков после запятой

// Мы можем преобразовать полученное значение в число, 
// используя унарный оператор + или Number(), 
// пример с унарным оператором: +num.toFixed(5).

// 3. Неточные вычисления

// Для хранения числа используется 64 бита: 
// 52 из них используется для хранения цифр, 
// 11 из них для хранения положения десятичной точки (если число целое, то хранится 0), 
// 1 бит отведён на хранение знака.

// Если число слишком большое, оно переполнит 
// 64-битное хранилище, JavaScript вернёт бесконечность:

// alert( 1e500 ); // Infinity

// Посмотрите на это (неверное!) сравнение:

// alert( 0.1 + 0.2 == 0.3 ); // false
// alert( 0.1 + 0.2 ); // 0.30000000000000004

// alert( 0.1.toFixed(20) ); // 0.10000000000000000555

// наиболее надёжный способ — это округлить результат используя метод 
// toFixed(n):

// let sum = 0.1 + 0.2;
// alert( sum.toFixed(2) ); // 0.30

// Помните, что метод toFixed всегда возвращает строку

// let sum = 0.1 + 0.2;
// alert( +sum.toFixed(2) ); // 0.3

// Забавный пример
// Привет! Я – число, растущее само по себе!
// alert( 9999999999999999 ); // покажет 10000000000000000

// Два нуля
// Другим забавным следствием внутреннего представления чисел 
// является наличие двух нулей: 0 и -0.

// Все потому, что знак представлен отдельным битом, так что, 
// любое число может быть положительным и отрицательным, включая нуль.

// 4. Проверка: isFinite и isNaN

// - Infinity (и -Infinity) — особенное численное значение, 
//   которое ведёт себя в точности как математическая бесконечность ∞.
// - NaN представляет ошибку.

// Эти числовые значения принадлежат типу number, 
// но они не являются «обычными» числами, 
// поэтому есть функции для их проверки:

// isNaN(value) 
// преобразует значение в число и проверяет является ли оно NaN:

// alert( isNaN(NaN) ); // true
// alert( isNaN("str") ); // true

// (!!!)NaN не является равным ни чему другому, даже самому себе:
// alert( NaN === NaN ); // false

// isFinite(value) 
// преобразует аргумент в число и возвращает true, если оно 
// является обычным числом, т.е. не NaN/Infinity/-Infinity:

// alert( isFinite("15") ); // true
// alert( isFinite("str") ); // false, потому что специальное значение: NaN
// alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity

// isFinite 
// используется для проверки, содержится ли в строке число:

// let num = +prompt("Enter a number", '');
// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
// alert( isFinite(num) );

// пустая строка интерпретируется как 0 во всех числовых функциях, включаяisFinite.

// 5. Сравнение Object.is

// Object.is
// специальный метод, который сравнивает значения примерно как ===, 
// но более надёжен в двух особых ситуациях:

// 5.1 Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
// 5.2 Значения 0 и -0 разные: Object.is(0, -0) === false, 
//     это редко используется, но технически эти значения разные.
// Во всех других случаях Object.is(a, b) идентичен a === b.

// 6. parseInt и parseFloat

// Для явного преобразования к числу можно использовать + или Number(). 
// Если строка не является в точности числом, то результат будет NaN:
// alert( +"100px" ); // NaN

// parseInt и parseFloat 
// «читают» число из строки. 
// Если в процессе чтения возникает ошибка, они возвращают 
// полученное до ошибки число. 
// Функция parseInt возвращает целое число, 
// а parseFloat возвращает число с плавающей точкой:

// alert( parseInt('100px') ); // 100
// alert( parseFloat('12.5em') ); // 12.5
// 
// alert( parseInt('12.3') ); // 12, вернётся только целая часть
// alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке

// Функции parseInt/parseFloat вернут NaN, 
// если не смогли прочитать ни одну цифру:

// alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения

// 6.1 Второй аргумент parseInt(str, radix)

// parseInt() 
// функция имеет необязательный второй параметр. 
// Он определяет систему счисления, таким образом 
// parseInt может также читать строки с шестнадцатеричными числами, 
// двоичными числами и т.д.:

// alert( parseInt('0xff', 16) ); // 255
// alert( parseInt('ff', 16) ); // 255, без 0x тоже работает
// alert( parseInt('2n9c', 36) ); // 123456

// 7. Другие математические функции

// В JavaScript встроен объект Math, 
// который содержит различные математические функции и константы.

// - Math.random()
// Возвращает псевдослучайное число в диапазоне от 0 (включительно) 
// до 1 (но не включая 1)

// - Math.max(a, b, c...) / Math.min(a, b, c...)
// Возвращает наибольшее/наименьшее число из перечисленных аргументов.
// alert( Math.max(3, 5, -10, 0, 1) ); // 5
// alert( Math.min(1, 2) ); // 1

// - Math.pow(n, power)
// Возвращает число n, возведённое в степень power
// alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024

// 8. Итого

// Чтобы писать числа с большим количеством нулей:
//  - Используйте краткую форму записи чисел – "e", с указанным количеством нулей. 
//    Например: 123e6 это 123 с 6-ю нулями 123000000.
//  - Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей. 
//    Например: 123e-6 это 0.000123 (123 миллионных).

// Для других систем счисления:
//  - Можно записывать числа сразу в шестнадцатеричной (0x), 
//    восьмеричной (0o) и 
//    бинарной (0b) системах счисления
//  - parseInt(str, base) преобразует строку в целое число в соответствии 
//    с указанной системой счисления: 2 ≤ base ≤ 36.
//  - num.toString(base) представляет число в строковом виде 
//    в указанной системе счисления base.

// Для преобразования значений типа 12pt и 100px в число:
//  - Используйте parseInt/parseFloat для «мягкого» преобразования 
//    строки в число, данные функции по порядку считывают число из строки 
//    до тех пор пока не возникнет ошибка.

// Для дробей:
//  - Используйте округления Math.floor, Math.ceil, Math.trunc, 
//    Math.round или num.toFixed(precision).
//  - Помните, что при работе с дробями происходит потеря точности.

/* 5.2.1 Задача. Сумма пользовательских чисел
Создайте скрипт, который запрашивает ввод двух чисел 
(используйте prompt) и после показывает их сумму. */

// моё решение
// let a = prompt('Введите первое число', '');
// let b = prompt('Введите второе число', '');
// 
// isFinite(a) & isFinite(b) ? alert( +a + +b ) : alert ( NaN ) 

// решение с книги
// let a = +prompt("Введите первое число", "");
// let b = +prompt("Введите второе число", "");
// 
// alert( a + b );

/* 5.2.2 Задача. Почему 6.35.toFixed(1) == 6.3?
Методы Math.round и toFixed, согласно документации, округляют 
до ближайшего целого числа: 
0..4 округляется в меньшую сторону, тогда как 
5..9 в большую сторону. */

// alert( 1.35.toFixed(1) ); // 1.4

// Но почему в примере ниже 6.35 округляется до 6.3?
// alert( 6.35.toFixed(1) ); // 6.3

// alert( 6.35.toFixed(20) ) // 6.34999999999999964473
// alert( (6.35 * 10).toFixed(20) ) //63.50000000000000000000
// alert( Math.round(6.35 * 10) / 10 ) // 6.4

/* 5.2.3 Задача. Ввод числового значения
Создайте функцию readNumber, которая будет запрашивать 
ввод числового значения до тех пор, пока посетитель его не введёт.
Функция должна возвращать числовое значение.
Также надо разрешить пользователю остановить процесс ввода, 
отправив пустую строку или нажав «Отмена». 
В этом случае функция должна вернуть null. */

// function readNumber() {
//   let num;
//   do {
//     num = prompt('Введите число?', '0');
//   } while ( !isFinite(num) );

//   if ( num === null || num === '' ) return null;

//   return +num;
// }

// alert(`Число: ${readNumber()}`);

// Решение немного сложнее, чем могло бы быть, 
// потому что нам надо обрабатывать null и пустую строку.

// запрашиваем ввод числового значения, пока посетитель его не введёт. 

// (!!!) null (отмена) и пустая строка ПРИ ПРИВЕДЕНИИ К ЧИСЛУ РАВНЫ 0. (!!!)

// После того, как цикл завершится, нам нужно проверить 
// введённое значение на null и пустую строку (вернуть null), 
// потому что после преобразования null в число, функция вернёт 0.

/* Задача 5.2.4 Бесконечный цикл по ошибке
Этот цикл – бесконечный. Он никогда не завершится, почему? 
let i = 0;
while (i != 10) {
  i += 0.2;
}
*/

// Потому что десятичная дробь никогда не равна ровно обозначенному числу
// alert( 0.2.toFixed(20) ) // 0.20000000000000001110

// Пояснение из книги
// Потому что i никогда не станет равным 10.
// Запустите скрипт и вы увидите реальные значения i:

// let i = 0;
// while (i < 11) {
  // i += 0.2;
  // if (i > 9.8 && i < 10.2) alert( i );
// }
// Ни одно из этих чисел не равно 10.
// Это происходит из-за потери точности, 
// при прибавлении таких дробей как 0.2.

// Вывод: избегайте проверок на равенство при работе 
// с десятичными дробями.

/* Задача 5.2.5 Случайное число от min до max
Встроенный метод Math.random() возвращает случайное число 
от 0 (включительно) до 1 (но не включая 1)
Напишите функцию random(min, max), 
которая генерирует случайное число с плавающей точкой 
от min до max (но не включая max). */

// function random(min, max) {
//   let num = min + Math.random() * (max - min);
//   return num
// }
// 
// alert( random (1, 5) )

// Решение из книги:
// function random(min, max) {
//   return min + Math.random() * (max - min);
// }






