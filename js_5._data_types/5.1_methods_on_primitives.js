// 1. Методы у примитивов

// JavaScript позволяет нам работать с примитивными типами данных – 
// строками, числами и т.д., как будто они являются объектами. 
// У них есть и методы

// Давайте взглянем на ключевые различия между примитивами и объектами

// 1.1 Примитив
// - Это – значение «примитивного» типа.
// - Есть 7 примитивных типов: 
//   string, number, boolean, symbol, null, undefined и bigint.

// 1.2 Объект
// - Может хранить множество значений как свойства.
// - Объявляется при помощи фигурных скобок {}, например: 
//   {name: "Рома", age: 30}. 
//   В JavaScript есть и другие виды объектов: 
//   например, функции тоже являются объектами.

// (!!!) Одна из лучших особенностей объектов – это то, 
//       что мы можем хранить функцию как одно из свойств объекта.

// let roma = {
//   name: "Рома",
//   sayHi: function() {
//     alert("Привет, дружище!");
//   }
// };
// 
// roma.sayHi(); // Привет, дружище!

// Здесь мы создали объект roma с методом sayHi.

// 2. Примитив как объект

// Вот парадокс, с которым столкнулся создатель JavaScript:

// - Есть много всего, что хотелось бы сделать с примитивами, 
// такими как строка или число. 
// Было бы замечательно, если бы мы могли работать с ними 
// через вызовы методов.
// - Примитивы должны быть лёгкими и быстрыми.

// Выбранное решение, хотя выглядит оно немного неуклюже:

// - Примитивы остаются примитивами. Одно значение, как и хотелось.
// - Язык позволяет осуществлять доступ к методам и свойствам 
//   строк, чисел, булевых значений и символов.
// - Чтобы это работало, при таком доступе создаётся специальный 
//   «объект-обёртка», который предоставляет нужную функциональность, 
//   а после удаляется.

// К примеру, существует метод 
// str.toUpperCase(), 
// который возвращает строку в верхнем регистре.

// Вот как он работает:
// let str = "Привет";
// alert( str.toUpperCase() ); // ПРИВЕТ

// Вот, что на самом деле происходит в str.toUpperCase():
// 2.1 Строка str – примитив. В момент обращения к его свойству, 
//     создаётся специальный объект, который знает значение строки 
//     и имеет такие полезные методы, как toUpperCase().
// 2.2 Этот метод запускается и возвращает новую строку (показывается в alert).
// 2.3 Специальный объект удаляется, оставляя только примитив str.

// Число имеет собственный набор методов. Например, 
// toFixed(n) 
// округляет число до n знаков после запятой.

// let n = 1.23456;
// alert( n.toFixed(2) ); // 1.23

// 3. Конструкторы String/Number/Boolean 
//    предназначены только для внутреннего пользования

// использование функций String/Number/Boolean без оператора new 
// – вполне разумно и полезно

// Они превращают значение в соответствующий примитивный тип: 
// в строку, в число, в булевый тип.

// К примеру, следующее вполне допустимо:
// let num = Number("123"); // превращает строку в число

// 4. null/undefined не имеют методов

// Особенные примитивы null и undefined являются исключениями

// У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов

// В некотором смысле, они «самые примитивные».

// Попытка доступа к свойствам такого значения возвратит ошибку:
// alert(null.test); // ошибка

// 5. Итого

// - Все примитивы, кроме null и undefined, предоставляют множество 
//   полезных методов. 
// - Формально эти методы работают с помощью временных объектов, 
//   но движки JavaScript внутренне очень хорошо оптимизируют этот процесс, 
//   так что их вызов не требует много ресурсов.


/* 5.1.1 Задача. Можно ли добавить свойство строке?
Взгляните на следующий код:

let str = "Привет";
str.test = 5; // (*)
alert(str.test);
Как вы думаете, это сработает? Что выведется на экран? */

// В зависимости от того, используете ли вы строгий режим (use strict) 
// или нет, результат может быть:
// - undefined (без strict)
// - Ошибка (strict mode)

// Почему? Давайте посмотрим что происходит в строке кода, отмеченной (*):

// - В момент обращения к свойству str создаётся «объект-обёртка».
// - В строгом режиме, попытка изменения этого объекта выдаёт ошибку.
// - Без строгого режима, операция продолжается, объект получает 
//   свойство test, но после этого он удаляется, так что на последней 
//   линии str больше не имеет свойства test.

// (!!!)Данный пример наглядно показывает, что 
// (!!!)примитивы не являются объектами.

// Они не могут хранить дополнительные данные.

