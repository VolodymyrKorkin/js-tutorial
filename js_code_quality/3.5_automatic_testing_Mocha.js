// Автоматическое тестирование означает, что тесты пишутся отдельно, в дополнение к коду. 
// Они по-разному запускают наши функции и сравнивают результат с ожидаемым.

// Behavior Driven Development (BDD)

// BDD – это три в одном: и тесты, и документация, и примеры использования.

// 1. Разработка функции возведения в степень — «pow»: спецификация

// Перед тем, как начать писать код функции pow, мы можем представить себе, что она должна делать, и описать её.
// Такое описание называется спецификацией (specification). 
// Она содержит описания различных способов использования и тесты для них, например:

// describe("pow", function() {
// 
//     it("возводит в степень n", function() {
//       assert.equal(pow(2, 3), 8);
//     });
//   
//   });

// Спецификация состоит из трёх основных блоков:

// - describe("заголовок", function() { ... })
// Какую функциональность мы описываем. В нашем случае мы описываем функцию pow. 
// Используется для группировки рабочих лошадок – блоков it.

// - it("описание", function() { ... })
// В первом аргументе блока it мы ЧЕЛОВЕЧЕСКИМ языком описываем конкретный способ использования функции, а 
// во втором – пишем функцию, которая тестирует данный случай.

// - assert.equal(value1, value2)
// Код внутри блока it, если функция работает верно, должен выполняться без ошибок.

// Функции вида assert.* используются для проверки того, что функция pow работает так, как мы ожидаем. 
// В этом примере мы используем одну из них – assert.equal, 
// которая сравнивает переданные значения и выбрасывает ошибку, если они не равны друг другу. 

// Существуют и другие типы сравнений и проверок, которые мы добавим позже.

// Спецификация может быть запущена, и при этом будет выполнена проверка, 
// указанная в блоке it, мы увидим это позднее.

// 2. Процесс разработки

// Процесс разработки обычно выглядит следующим образом:
// 2.1 Пишется начальная спецификация с тестами, проверяющими основную функциональность.
// 2.2 Создаётся начальная реализация.
// 2.3 Для запуска тестов мы используем фреймворк Mocha (подробнее о нём чуть позже). 
//     Пока функция не готова, будут ошибки. Вносим изменения до тех пор, пока всё не начнёт работать так, как нам нужно.
// 2.4 Теперь у нас есть правильно работающая начальная реализация и тесты.
// 2.5 Мы добавляем новые способы использования в спецификацию, возможно, ещё не реализованные в тестируемом коде. 
//     Тесты начинают «падать» (выдавать ошибки).
// 2.6 Возвращаемся на шаг 3, дописываем реализацию до тех пор, пока тесты не начнут завершаться без ошибок.
// 2.7 Повторяем шаги 3-6, пока требуемая функциональность не будет готова.

// Таким образом, разработка проходит итеративно. 
// Мы пишем спецификацию, реализуем её, проверяем, что тесты выполняются без ошибок, 
// пишем ещё тесты, снова проверяем, что они проходят и т.д.

// 3. Спецификация в действии

// JavaScript-библиотеками для тестов:

// Mocha – основной фреймворк. Он предоставляет общие функции тестирования, 
// такие как describe и it, а также функцию запуска тестов.

// Chai – библиотека, предоставляющая множество функций проверки утверждений. 
// Пока мы будем использовать только assert.equal.

// Sinon – библиотека, позволяющая наблюдать за функциями, эмулировать встроенные функции и многое другое. 
// Нам она пригодится позднее.

// Эти библиотеки подходят как для тестирования внутри браузера, так и на стороне сервера.

// Cуществуют более высокоуровневые фреймворки для тестирования, такие как karma и другие. 
// С их помощью легко сделать автозапуск множества тестов.

// Полная HTML-страница с этими библиотеками и спецификацией функции pow 
// см. indexTests.html папка 3.5_automatic_testing_Mocha_practice

// Условно страницу "indexTests.html" можно разделить на пять частей:

// 3.1 Тег <head> содержит сторонние библиотеки и стили для тестов.
// 3.2 Тег <script> содержит тестируемую функцию, в нашем случае – pow.
// 3.3 Тесты – в нашем случае внешний скрипт test.js, который содержит спецификацию describe("pow", ...),
//     представленную выше.
// 3.4 HTML-элемент <div id="mocha"> будет использован фреймворком Mocha для вывода результатов тестирования.
// 3.5 Запуск тестов производится командой mocha.run().

// 4. Улучшаем спецификацию

// есть два пути организации тестов:
// 4.1 Первый – добавить ещё один assert в существующий it:
// describe("pow", function() {
// 
//     it("возводит число в степень n", function() {
//       assert.equal(pow(2, 3), 8);
//       assert.equal(pow(3, 3), 27);
//     });
//   
//   });

// 4.2 Второй – написать два теста:
// describe("pow", function() {
// 
//     it("2 в степени 3 будет 8", function() {
//       assert.equal(pow(2, 3), 8);
//     });
//   
//     it("3 в степени 3 будет 27", function() {
//       assert.equal(pow(3, 3), 27);
//     });
//   
//   });

// Принципиальная разница в том, что когда один из assert выбрасывает ошибку, то выполнение it блока тут же прекращается. 
// Таким образом, если первый assert выбросит ошибку, результат работы второго assert мы уже не узнаем.

// Разделять тесты предпочтительнее, так как мы получаем больше информации о том, что конкретно пошло не так.

// !!! Один тест проверяет одну вещь.

// 5. Вложенные блоки describe

// before/after и 
// beforeEach/afterEach

// Мы можем задать before/after функции, которые будут выполняться до/после тестов, а также 
// функции beforeEach/afterEach, выполняемые до/после каждого it.

// Например:
// describe("тест", function() {

//   before(() => alert("Тестирование началось – перед тестами"));
//   after(() => alert("Тестирование закончилось – после всех тестов"));

//   beforeEach(() => alert("Перед тестом – начинаем выполнять тест"));
//   afterEach(() => alert("После теста – заканчиваем выполнение теста"));

//   it('тест 1', () => alert(1));
//   it('тест 2', () => alert(2));

// });

// Порядок выполнения будет таким:
// Тестирование началось – перед тестами (before)
// Перед тестом – начинаем выполнять тест (beforeEach)
// 1
// После теста – заканчиваем выполнение теста (afterEach)
// Перед тестом – начинаем выполнять тест (beforeEach)
// 2
// После теста – заканчиваем выполнение теста (afterEach)
// Тестирование закончилось – после всех тестов (after)

// Обычно beforeEach/afterEach и before/after используются для инициализации, 
// обнуления счётчиков или чего-нибудь ещё между тестами (или группами тестов).

// 6. Расширение спецификации

// Другие функции сравнения
// Обратите внимание на assert.isNaN. Это проверка того, что переданное значение равно NaN.

// Библиотека Chai содержит множество других подобных функций, например:
// assert.equal(value1, value2) – проверяет равенство value1 == value2.
// assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.
// assert.notEqual, assert.notStrictEqual – проверяет неравенство и строгое неравенство соответственно.
// assert.isTrue(value) – проверяет, что value === true
// assert.isFalse(value) – проверяет, что value === false
// …с полным списком можно ознакомиться в документации

// ! 7. Итого
// В BDD сначала пишут спецификацию, а потом реализацию. В конце у нас есть и то, и другое.

// Спецификацию можно использовать тремя способами:
// - Как Тесты – они гарантируют, что функция работает правильно.
// - Как Документацию – заголовки блоков describe и it описывают поведение функции.
// - Как Примеры – тесты, по сути, являются готовыми примерами использования функции.

// Не имея тестов, людям приходится выбирать один из двух путей:
// - Внести изменения, и неважно, что будет. Потом у наших пользователей станут проявляться ошибки, 
//   ведь мы наверняка что-то забудем проверить вручную.
// - Или же, если наказание за ошибки в коде серьёзное, то люди просто побоятся вносить изменения в такие функции. 
//   Код будет стареть, «зарастать паутиной», и никто не захочет в него лезть. Это нехорошо для разработки.
