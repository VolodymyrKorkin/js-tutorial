// 1. Цикл «while»

// let i = 0;
// while (i < 3) { // выводит 0, затем 1, затем 2
//   alert( i );
//   i++;
// }

// Условие while вычисляется и преобразуется в логическое значение.
// Например, while (i) – более краткий вариант while (i != 0):

// let i = 3;
// while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
//   alert( i );
//   i--;
// }

// Фигурные скобки не требуются для тела цикла из одной строки
// let i = 3;
// while (i) alert(i--);

// Цикл «do…while»

// do {
// // тело цикла
// } while (condition);

// Цикл сначала выполнит тело, а затем проверит условие condition, 
// и пока его значение равно true, он будет выполняться снова и снова.

// Например:
// let i = 0;
// do {
// alert( i );
// i++;
// } while (i < 3);

// Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла 
// выполнилось хотя бы один раз, даже если условие окажется ложным. 
// На практике чаще используется форма с предусловием: while(…) {…}.

// 2. Цикл «for»

// for (начало; условие; шаг) {
//     // ... тело цикла ...
//   }

// Цикл ниже выполняет alert(i) для i от 0 до (но не включая) 3:
// for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
//     alert(i);
//   }

// В примере переменная счётчика i была объявлена прямо в цикле. 
// Это так называемое «встроенное» объявление переменной. 
// Такие переменные существуют только внутри цикла.
// for (let i = 0; i < 3; i++) {
//   alert(i); // 0, 1, 2
// }
// alert(i); // ошибка, нет такой переменной

// Вместо объявления новой переменной мы можем использовать уже существующую:
// let i = 0;

// for (i = 0; i < 3; i++) { // используем существующую переменную
//   alert(i); // 0, 1, 2
// }
// alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла

// Любая часть for может быть пропущена.

// пропустить начало
// let i = 0; // мы уже имеем объявленную i с присвоенным значением

// for (; i < 3; i++) { // нет необходимости в "начале"
//   alert( i ); // 0, 1, 2
// }

// Можно убрать и шаг:
// let i = 0;

// for (; i < 3;) {
//   alert( i++ );
// }
// Это сделает цикл аналогичным while (i < 3).

// !!!При этом сами точки с запятой ; обязательно должны присутствовать, 
// иначе будет ошибка синтаксиса.

// 3. Прерывание цикла: «break»

// Мы можем выйти из цикла в любой момент с помощью специальной директивы break.

// Например, следующий код подсчитывает сумму вводимых чисел до тех пор, 
// пока посетитель их вводит, а затем – выдаёт:
// let sum = 0;
// while (true) {
//   let value = +prompt("Введите число", ''); // + переводит вводимые числа из строки в число
//   if (!value) break; // (*)
//   sum += value;
// }
// alert( 'Сумма: ' + sum );

// Директива break в строке (*) полностью прекращает выполнение цикла и 
// передаёт управление на строку за его телом, то есть на alert.

// Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, 
// когда условие, по которому нужно прерваться, находится не в начале или конце цикла, 
// а посередине.

// 4. Переход к следующей итерации: continue

// Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, 
// а переходит к следующей итерации (если условие все ещё равно true).

// Её используют, если понятно, что на текущем повторе цикла делать больше нечего.

// Например, цикл ниже использует continue, чтобы выводить только нечётные значения:
// for (let i = 0; i < 10; i++) {

//   // если true, пропустить оставшуюся часть тела цикла
//   if (i % 2 == 0) continue;

//   alert(i); // 1, затем 3, 5, 7, 9
// }

// Для чётных значений i, директива continue прекращает выполнение тела цикла 
// и передаёт управление на следующую итерацию for (со следующим числом). 
// Таким образом alert вызывается только для нечётных значений.
// for (let i = 0; i < 10; i++) {
// if (i % 2) {
//     alert( i );
// }  
// }

// С технической точки зрения он полностью идентичен. 
// Действительно, вместо continue можно просто завернуть действия в блок if.

// Однако мы получили дополнительный уровень вложенности фигурных скобок. 
// Если код внутри if более длинный, то это ухудшает читаемость, в отличие от варианта с continue.

//  !!!Нельзя использовать break/continue справа от оператора „?“

// (i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке

// 5. Метки для break/continue

// Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.
// Достичь желаемого поведения можно с помощью меток.
// Метка имеет вид идентификатора с двоеточием перед циклом:
// labelName: for (...) {
//     ...
//   }

// Вызов break <labelName> в цикле ниже ищет ближайший внешний цикл с такой меткой и 
// переходит в его конец.

// outer: for (let i = 0; i < 3; i++) {

//   for (let j = 0; j < 3; j++) {

//     let input = prompt(`Значение на координатах (${i},${j})`, '');

//     // если пустая строка или Отмена, то выйти из обоих циклов
//     if (!input) break outer; // (*)

//     // сделать что-нибудь со значениями...
//   }
// }
// alert('Готово!');

// В примере выше это означает, что вызовом break outer будет разорван внешний цикл до метки 
// с именем outer, и управление перейдёт со строки, помеченной (*), к alert('Готово!').

// Можно размещать метку на отдельной строке:

// outer:
// for (let i = 0; i < 3; i++) { ... }

// Директива continue также может быть использована с меткой. 
// В этом случае управление перейдёт на следующую итерацию цикла с меткой.

// Метки не дают возможности передавать управление в произвольное место кода.
// Например, нет возможности сделать следующее:

// break label; // не прыгает к метке ниже
// label: for (...)

// Вызов break/continue возможен только внутри цикла, и метка должна находиться 
// где-то выше этой директивы.

/* Задание 2.13.1. Последнее значение цикла.
Какое последнее значение выведет этот код? Почему? */
// let i = 3;
// while (i) {
//   alert( i-- ); // 1, потому что при i = 0 while(i) = false
// }

/* Задание 2.13.2. Какие значения выведет цикл while?.
Для каждого цикла запишите, какие значения он выведет. 
Потом сравните с ответом.
Оба цикла выводят alert с одинаковыми значениями или нет? */

// Префиксный вариант ++i:
// let i = 0;
// while (++i < 5) alert( i ); // 1, 2, 3, 4

// Постфиксный вариант i++
// let i = 0;
// while (i++ < 5) alert( i ); // 1, 2, 3, 4, 5 (сначала сравнение i = 0 > 5, потом увеличение i до 1,
// потом alert(i = 1))

// !!!Оператор i++ увеличивает i, возвращая СТАРОЕ значение

/* Задание 2.13.3. Какие значения выведет цикл for?*/
// Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.
// Оба цикла выведут alert с одинаковыми значениями или нет?
// Постфиксная форма:
// for (let i = 0; i < 5; i++) alert( i ); // 0, 1, 2, 3, 4

// Префиксная форма:
// for (let i = 0; i < 5; ++i) alert( i ); 0, 1, 2, 3, 4
