// Строгое сравнение

// Использование обычного сравнения == может вызывать проблемы. Например, оно не отличает 0 от false:
// alert( 0 == false ); // true

// Та же проблема с пустой строкой:
// alert( '' == false ); // true

// Это происходит из-за того, что операнды разных типов преобразуются оператором == к числу. 
// В итоге, и пустая строка, и false становятся нулём.

// Как же тогда отличать 0 от false?

// Оператор строгого равенства === проверяет равенство без приведения типов.

// Другими словами, если a и b имеют разные типы, то проверка a === b немедленно возвращает false без попытки их преобразования.
// Давайте проверим:
// alert( 0 === false ); // false, так как сравниваются разные типы
// Ещё есть оператор строгого неравенства !==, аналогичный !=.
// Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше места для ошибок.

// Сравнение с null и undefined

// При строгом равенстве ===
// Эти значения различны, так как различны их типы.
// alert( null === undefined ); // false

// При нестрогом равенстве ==
// Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
// alert( null == undefined ); // true

// При использовании математических операторов и других операторов сравнения < > <= >=
// Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

// Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила. И, что более важно, как избежать ошибок при их использовании.

// Странный результат сравнения null и 0
// Сравним null с нулём:

// alert( null > 0 );  // (1) false
// alert( null == 0 ); // (2) false
// alert( null >= 0 ); // (3) true
// С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "null больше или равно нулю", 
// тогда результат одного из сравнений выше должен быть true, но они оба ложны.

// Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, 
// рассматривая его как 0. Поэтому выражение (3) null >= 0 истинно, а null > 0 ложно.

// С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: 
// эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) null == 0 ложно.

// Несравненное значение undefined
// Значение undefined несравнимо с другими значениями:

// alert( undefined > 0 ); // false (1)
// alert( undefined < 0 ); // false (2)
// alert( undefined == 0 ); // false (3)
// Почему же сравнение undefined с нулём всегда ложно?

// На это есть следующие причины:

// Сравнения (1) и (2) возвращают false, потому что undefined преобразуется в NaN, 
// а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
// Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше.

/* Задание 2.9.1 Каким будет результат этих выражений? */
// 5 > 4 // true
// "ананас" > "яблоко" // false
// "2" > "12" // true (сравнение строк без преобразования в числа)
// undefined == null // true Специальный случай. Значения null и undefined равны только друг другу при нестрогом сравнении.
// undefined === null // false
// null == "\n0\n" // false (Специальный случай. Значения null и undefined равны только друг другу при нестрогом сравнении.)
// null === +"\n0\n" // false